# Type-safe API Handler

## Table of Contents

- [Overview](#overview)
- [Setup](#setup)
- [Basic Usage](#basic-usage)
  - [Validating Requests](#validating-requests)
  - [Responses](#responses)
  - [Sending HTTP Errors](#sending-http-errors)
- [Lifecycle Hooks](#lifecycle-hooks)
  - [Hook List](#hook-list)
  - [Ideas/Concepts for Use](#ideasconcepts-for-use)
- [Bells and Whistles](#bells-and-whistles)
  - [Logging](#logging)
  - [Development Mode](#development-mode)
- [Future Features](#future-features)
  - [Enhancements](#enhancements)
  - [Standard Middleware Functions](#standard-middleware-functions)

## Overview

The Type-safe API handler offers a practical solution for maintaining Lambda-based APIs in TypeScript. It leverages a validation library called valibot to parse incoming HTTP requests against predefined schemas, ensuring data integrity and minimizing the risk of errors.

This API handler follows a straightforward approach, allowing developers to define routes and their corresponding handlers with ease. Middleware functions can be seamlessly integrated to handle common concerns like auth, CORS, rate limiting, and more!

All of this ties into the Rapidstack toolkit to handle consistent logging and caching.

## Setup

To start, install the lambda package:

```sh
pnpm add @rapidstack/lambda
# or
npm i @rapidstack/lambda
```

Define an app-level toolkit for your project:

```ts
import { createToolkit } from '@rapidstack/lambda';

const toolkit = createToolkit({ app: 'My-App' });
```

Create the API handler using the factory:

```ts
import { TypeSafeApiHandler } from '@rapidstack/lambda';

const createHandler = toolkit.create(TypeSafeApiHandler);
```

This returned function will create the Lambda handler. Just supply your routes list:

```ts
const routes = {
  hello: {
    // get: /* GET request handler for {domain}/hello */
  },
  nested: {
    hello: {
      // get: /* GET request handler for {domain}/nested/hello */
    },
  },
};

export const handler = createHandler(routes);
```

Now we're ready to go over the basic usage of the API handler.

## Basic Usage

### Validating Requests

The `validate` function allows you to supply valibot schemas to parse and then infer the typescript output. The available validators are:

- `qsp`: to parse query string parameters
- `body`: to parse the request body
- `pathParams`: to parse path parameters
- `headers`: to parse request headers
- `cookies`: to parse request cookies

Each of these validators must be a valibot object schema, as that is the format
that is supplied to the underlying `validate` function. It also simplifies the inferred output for the `validated` object in your route handler.

Here is an example of a simple validator that requires a query string parameter for the `GET /hello` route. If the `name` parameter is not present, the request will be rejected with a 400 Bad Request error automatically and will include helpful error details.

```ts
import type { ApiValidatorSchemas } from '@rapidstack/lambda';

import { validate } from '@rapidstack/lambda';
import { object, string } from 'valibot';

const HelloValidator: ApiValidatorSchemas = {
  qsp: object({
    name: string(
      'The query string parameter `name` is required for this request!'
    ),
  }),
};

const routes = {
  hello: {
    get: validate(HelloValidator, async ({ validated }) => {
      return {
        body: {
          response: `Hello, ${validated.qsp.name}!`,
        },
        statusCode: 200,
      };
    }),
  },
};
```

### Responses

Now that we have a handler defined, let's go over the standard response shapes generated by the API. The shape of the response for the handler is loosely based on the JSend specification, where the response is an object with a `status` key and a `data` key. All body data will automatically get wrapped in this data key. The `status` key can be one of the following:

- `success`: The request was successful - (1xx, 2xx, 3xx).
- `invalid`: The request failed specially due to a validation failure - (400).
- `fail`: The request failed due to a client error - (other 4xx).
- `error`: The request failed due to a server error - (5xx).

Using the above example, the response for the `GET /hello` route will look like this:

```json
// success: {domain}/hello?name=Jake
{
  "data": {
    "response": "Hello, Jake!"
  },
  "status": "success"
}
```

```json
// failure: {domain}/hello?bad=key
{
  "data": {
    "description": "The server could not understand the request due to invalid syntax.",
    "messages": [
      "The query string parameter `name` is required for this request!"
    ],
    "schema": {
      "qsp": ["qsp.name: string"]
    },
    "title": "Bad Request"
  },
  "status": "invalid"
}
```

And let's say we had that endpoint fail with a 403 for all users that aren't "Bob":

```json
// failure: {domain}/hello?name=Jake
{
  "data": {
    "description": "The request or action is prohibited or you do not have necessary permissions with your current credentials.",
    "title": "Forbidden"
  },
  "status": "fail"
}
```

### Sending HTTP Errors

To send an HTTP error, you can throw an instance of the `HttpError` class. This will automatically generate the appropriate response for the error code you supply. This works for all 4xx and 5xx error codes.

```ts
import { HttpError } from '@rapidstack/lambda';

const routes = {
  hello: {
    get: validate(HelloValidator, async ({ validated }) => {
      if (validated.qsp.name !== 'Bob') throw new HttpError(403);

      return {
        body: {
          response: `Hello, ${validated.qsp.name}!`,
        },
        statusCode: 200,
      };
    }),
  },
};
```

## Lifecycle Hooks

Along with the route object, an options object can also be provided to the create handler function:

```ts
import { TypeSafeApiHandler } from '@rapidstack/lambda';

const createHandler = toolkit.create(TypeSafeApiHandler);

const routes = {
  /* your routes here */
};
const hooks = {
  // onRequestStart: /* a lifecycle hook */
};

export const handler = createHandler(routes, hooks);
```

These hooks allow you to tap into specific points in the request lifecycle to perform additional actions.

### Hook List

The lifecycle of a request with lifecycle hooks is as follows:

```txt
REQUEST START
  |
  |-> hook: onHotFunctionTrigger -> terminate
  |
  |-> find route
  |
  |->|
     |-> hook: onRequestStart
     |
     |-> validate incoming request against route schema
     |
     |-> run route handler function
     |
     |-> hook: onRequestEnd
     |
     |-> hook: onError (catches error for the indented)
  |<-|
  |
  |-> format response
  |
REQUEST END

```

- `onHotFunctionTrigger`: Runs when an event matches the Rapidstack hot function trigger (coming soon).
  - Arguments: `context`, `cache`, `logger`
- `onRequestStart`: Runs before the main route handler function. This is a good place to do things like logging the request, or checking for rate limits. If returning void, the request will continue on. If returning a function, the lifecycle will immediately terminate and the response of the function will be sent back to the client.
  - Arguments: `event`, `context`, `cache`, `logger`, `responseContext`, `routeInfo`
- `onRequestEnd`: Runs after the main route handler function. This is a good place to do things like logging the response, or setting headers. If returning void, the request will continue on. If returning a function, the lifecycle will immediately terminate and the response of this function will be sent back to the client. The response of the route handler function will be ignored.
  - Arguments: `event`, `context`, `cache`, `logger`, `responseContext`, `routeInfo`, `result`
- `onError`: Runs when an error is thrown in the `onRequestStart` hook, main route handler function, or `onRequestEnd` hook. This is a good place to log the error, or to format the error response. If returning void, the error will be sent back to the client. If returning a function, the lifecycle will immediately terminate and the response of this function will be sent back to the client. Re-throwing non-`HttpError` errors will result in a 500 error response and the lambda will report it as a failed lambda execution.
  - Arguments: `event`, `context`, `cache`, `logger`, `responseContext`, `routeInfo`, `error`
- `onLambdaShutdown`: Runs when the Lambda is shutting down. This is a good place to do things like clean up resources or connections.
  - Arguments: none.

Referenced function argument descriptions:

- `event`: The AWS Lambda event object.
- `context`: The AWS Lambda context object.
- `cache`: The common in-memory cache from the toolkit.
- `logger`: The common JSON logger from the toolkit.
- `responseContext`: A shared object to set accumulated headers or cookies between hooks.
- `routeInfo`: Info on the matched route, all routes that can be called, and neighboring verbs for this route.
- `result`: The response object from the route handler function.

### Ideas/Concepts for Use

```ts
const hooks = {
  onRequestStart: async (params) => {
    params.logger.info({ msg: 'request info', event: params.event });

    // Send cors for all responses
    await corsMiddleware(params, ['https://example.com']);

    // The following can throw be processed in parallel
    await Promise.all([
      rateLimiterMiddleware(params),
      authorizerMiddleware(params),
    ]);
  },
  onRequestEnd: async (params) => {
    // coming soon: A standard way to audit a REST API to ensure it is following
    // best practices
    if (process.env.DEVELOPMENT) {
      const { lintApiCall } = await import('@rapidstack/lambda/api-linter');
      await lintApiCall(params);
    }

    // Set a header for all responses
    params.responseContext.headers['X-Xss-Protection'] = '0';
  },
  onError: async ({ error, ...params }) => {
    params.logger.error({ msg: 'error info', error });

    if (error instanceof HttpError) {
      if (error.code === 404) {
        return {
          body: 'whoops!',
          statusCode: 404,
        };
      }
    }

    if (error instanceof AuthError) {
      // Note: HttpError is handled by an internal system to format it into
      // a response, so that error can be thrown within this hook without
      // worry. Just know that it will not get handled by any logic in this
      // hook.

      // don't throw auth error info, be purposefully vague
      throw new HttpError(401);
    }

    // if error isn't handled in here, it will result in a failed lambda
    // execution
  },
};
```

## Bells and Whistles

## Future Features

The base of the handler is complete and modifications will be smaller enhancements and a standard set of middleware functions to tie in with hooks.

### Enhancements

- The validator function would validate auth details if there are requirements for scope, user, etc.
- Custom cookie encodings
- Being able to pass in certain headers to cause debug actions (advanced logging, skipping internal cache, etc.)
- A tRPC-like method for getting TypeScript definitions for the API using inferred types from the valibot schemas and handler returns:

  ```ts
  import type { MakeTypedApi } from '@rapidstack/lambda';

  const routes = { /* your route definitions */ };
  export type TypedApi = MakeTypedApi<typeof routes>;
  //              ^ import into your frontend folder
  ```

### Standard Middleware Functions

- OpenAPI route
  - Would be added to the `onRequestStart` hook to intercept a set route, i.e.: `{base-url}/open-api` and return a webpage to:
    - View and try API routes
    - Download TypeScript types for each endpoint
    - Download a postman collection of the API
- CORS
  - (this is handled with API Gateway, but can be configured for lambda urls)
- Rate Limiting
  - Would have a corresponding cloud construct to spin up a dynamo table and permissions for the lambda to access it
- Auth handlers for Cognito, JWT, IAM, etc.
- "API Linting" to ensure the API is following best practices. Violations would be sent to a SNS topic for further processing.
